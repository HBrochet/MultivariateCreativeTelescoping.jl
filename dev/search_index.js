var documenterSearchIndex = {"docs":
[{"location":"OreAlgebra/","page":"Ore algebra","title":"Ore algebra","text":"The first step is to define an algebra using the OreAlg function.","category":"section"},{"location":"OreAlgebra/#Definition-of-an-Ore-algebra","page":"Ore algebra","title":"Definition of an Ore algebra","text":"The following command creates an object of type OreAlg.\n\nchar is the characteristic of the base field and is 0 by default .\nratvars is a vector of string representing rational variables in the base field.\nratdiffvars is a pair of vectors of same length representing pairs of variables (t_id_t_i)  satisfying the relation d_t_it_i = t_i d_t_i +1. The variables t_i are part of the base field  and the variables d_t_i are polynomial variables. \npoldiffvars is a pair of vectors of same length representing pairs of variables (x_id_x_i)  satisfying the relation d_x_ix_i = x_i d_x_i +1. The variables x_i and d_x_i are polynomial variables \npolvars is a vector of string representing polynomial variables.\nlocvars is a pair of vectors of same length representing pairs (T_ip_i) where T_i are variable names  and p_i are parsable polynomials in all the previous variables except for d_t_i and d_x_i.  The variables T_i corresponds to the inverse of p_i and satisfy the commutation rule  d_u T = Td_u - partial_u(p_i)T^2 for any uin  x_jt_j.\norder is a parsable order of the form \"ord var1 ... varn > ord var1 ... varm > ...\"  where ord is currently either lex or grevlex and vari names of the previous variables. \nnomul is a vector of strings. If a name of a polynomial variable is in this vector then no multiplication by this   variable will be performed during Gröbner basis computations.","category":"section"},{"location":"OreAlgebra/#Example","page":"Ore algebra","title":"Example","text":"The algebra mathbbQ(t)xlangle partial_t partial_xrangle with the order lex dt > grevlex x dx can be defined with the command\n\njulia> using MultivariateCreativeTelescoping\n\njulia> A = OreAlg(order = \"lex dt > grevlex x dx\",ratdiffvars=([\"t\"],[\"dt\"]),poldiffvars=([\"x\"],[\"dx\"]))\nOre algebra","category":"section"},{"location":"OreAlgebra/#Creating-Ore-polynomials","page":"Ore algebra","title":"Creating Ore polynomials","text":"The most convenient method to create elements of an algebra A is to use the parse_OrePoly and parse_vector_OrePoly functions. ","category":"section"},{"location":"OreAlgebra/#Example-2","page":"Ore algebra","title":"Example","text":"Continuing the previous example:\n\njulia> p = parse_OrePoly(\"t*dt + x*dx\",A)\nOre polynomial\n\njulia> vec = parse_vector_OrePoly(\"[x*dx, dt*t, dx*(t-x), x^4*dt^5]\", A)\nVector of Ore polynomials","category":"section"},{"location":"OreAlgebra/#Printing-Ore-polynomials","page":"Ore algebra","title":"Printing Ore polynomials","text":"Printing is done with the prettyprint function based on information stored in the algebra A. Remark that the package uses a standard monomial basis with the derivatives w.r.t. polynomial variables on the left. This is unusual but actually more efficient for the computations done in this package.","category":"section"},{"location":"OreAlgebra/#Example-3","page":"Ore algebra","title":"Example","text":"Continuing the previous example:\n\njulia> prettyprint(p,A)\n(t)dt + (1)dxx + (-1)\n\njulia> prettyprint(vec,A)\nvector of 4 OrePoly\n(1)dxx + (-1)\n(t)dt + (1)\n(-1)dxx + (t)dx\n(1)dt^5x^4","category":"section"},{"location":"OreAlgebra/#Operations-on-Ore-polynomials","page":"Ore algebra","title":"Operations on Ore polynomials","text":"Here is a list of basic operations that are supported by this package. Feel free to contact me if you wish to have access to other functions. ","category":"section"},{"location":"OreAlgebra/#Exporting-Ore-polynomials-to-other-systems","page":"Ore algebra","title":"Exporting Ore polynomials to other systems","text":"It is possible to convert an OrePoly of a vector of OrePoly to a parsable string which can be parsed by other computer algebra systems.","category":"section"},{"location":"OreAlgebra/#Example-4","page":"Ore algebra","title":"Example","text":"Continuing the previous example:\n\njulia> mystring(p,A)\n\"(t)*dt*1 + (1)*dx*x*1 + (-1)*1\"\n\njulia> mystring(vec,A)\n\"[(1)*dx*x*1 + (-1)*1, (t)*dt*1 + (1)*1, (-1)*dx*x*1 + (t)*dx*1, (1)*dt^5*x^4*1]\"","category":"section"},{"location":"OreAlgebra/#MultivariateCreativeTelescoping.OreAlg","page":"Ore algebra","title":"MultivariateCreativeTelescoping.OreAlg","text":"OreAlg(;char :: Int = 0,\n        ratvars :: Vector{String} = String[],\n        ratdiffvars :: Tuple{Vector{String},Vector{String}}=(String[],String[]), \n        poldiffvars :: Tuple{Vector{String},Vector{String}}=(String[],String[]), \n        polvars :: Vector{String} = String[],\n        locvars :: Tuple{Vector{String},Vector{String}} = (String[],String[]),\n        order :: String = \"\",\n        nomul :: Vector{String} = String[]\n\n\n\n\n\n","category":"type"},{"location":"OreAlgebra/#MultivariateCreativeTelescoping.parse_OrePoly","page":"Ore algebra","title":"MultivariateCreativeTelescoping.parse_OrePoly","text":"parse_OrePoly(s :: String, A :: OreAlg)\n\nReturn an OrePoly corresponding to the parseable string s in the algebra.\n\n\n\n\n\n","category":"function"},{"location":"OreAlgebra/#MultivariateCreativeTelescoping.parse_vector_OrePoly","page":"Ore algebra","title":"MultivariateCreativeTelescoping.parse_vector_OrePoly","text":"parse_vector_OrePoly(s :: String, A :: OreAlg)\n\nReturn a vector of OrePoly corresponding to the parseable string s in the algebra A.\n\n\n\n\n\n","category":"function"},{"location":"OreAlgebra/#MultivariateCreativeTelescoping.prettyprint","page":"Ore algebra","title":"MultivariateCreativeTelescoping.prettyprint","text":"prettyprint(p :: OrePoly,A ::OreAlg)\n\nPrint the OrePoly p.\n\n\n\n\n\nprettyprint(v :: Vector{OrePoly{K,M}},A :: OreAlg)\n\nPrint the vector of OrePoly v.\n\n\n\n\n\n","category":"function"},{"location":"OreAlgebra/#MultivariateCreativeTelescoping.add-Tuple{OrePoly, OrePoly, OreAlg}","page":"Ore algebra","title":"MultivariateCreativeTelescoping.add","text":"add(p :: OrePoly, q :: OrePoly, A :: OreAlg)\n\nReturn the Ore polynomial p + q.\n\n\n\n\n\n","category":"method"},{"location":"OreAlgebra/#MultivariateCreativeTelescoping.sub-Tuple{OrePoly, OrePoly, OreAlg}","page":"Ore algebra","title":"MultivariateCreativeTelescoping.sub","text":"sub(p :: OrePoly, q :: OrePoly, A :: OreAlg)\n\nReturn the Ore polynomial p - q.\n\n\n\n\n\n","category":"method"},{"location":"OreAlgebra/#MultivariateCreativeTelescoping.mul-Tuple{OrePoly, OrePoly, OreAlg}","page":"Ore algebra","title":"MultivariateCreativeTelescoping.mul","text":"mul(p :: OrePoly, q :: OrePoly, A :: OreAlg)\n\nReturn the Ore polynomial pq.\n\n\n\n\n\n","category":"method"},{"location":"OreAlgebra/#Base.length-Tuple{OrePoly}","page":"Ore algebra","title":"Base.length","text":"Base.length(p :: OrePoly)\n\nReturn the number of terms in the polynomial p.\n\n\n\n\n\n","category":"method"},{"location":"OreAlgebra/#MultivariateCreativeTelescoping.mystring","page":"Ore algebra","title":"MultivariateCreativeTelescoping.mystring","text":"mystring(p :: OrePoly, A:: OreAlg)\n\nReturns a string representing the Ore polynomial p.\n\n\n\n\n\nmystring(v :: Vector{OrePoly{K,M}}, A:: OreAlg)\n\nReturns a string representing the vector of Ore polynomials v.\n\n\n\n\n\n","category":"function"},{"location":"OtherFunctionalities/#Gröbner-bases","page":"Other functionalities","title":"Gröbner bases","text":"This package implements two algorithms to compute Gröbner bases, namely F4 and F5. The F5 implementation is based on Lairez2024. It is recommended to use the F4 implementation as it is faster.","category":"section"},{"location":"OtherFunctionalities/#Example","page":"Other functionalities","title":"Example","text":"julia> using MultivariateCreativeTelescoping\n\njulia>  A = OreAlg(order=\"grevlex x y > grevlex dx dy\",poldiffvars=([\"x\",\"y\"],[\"dx\",\"dy\"]))\nOre algebra\n\njulia> g = parse_vector_OrePoly(\"[dx - 2*x, dy + 3*y^2]\",A)\nVector of Ore polynomials\n    \njulia> gb1 = f4(g,A)\nVector of Ore polynomials\n\njulia> gb2 = f5(g,A)\nVector of Ore polynomials\n\njulia> gb1 == gb2\ntrue \n\njulia> prettyprint(gb1,A)\nvector of 2 OrePoly\n(1)y^2 + (1//3)dy\n(1)x + (-1//2)dx","category":"section"},{"location":"OtherFunctionalities/#Weyl-closure","page":"Other functionalities","title":"Weyl closure","text":"Let D be the algebra \n\n D = mathbbQ(boldsymbolt)boldsymbolxlangle partial_boldsymbolt partial_boldsymbolxrangle\n\nwhere boldsymbolt =(t_1dotst_m) and boldsymbolx = (x_1dotsx_n).\n\nLet R be the same algebra as with rational coefficients\n\nR = mathbbQ(boldsymboltboldsymbolx)langle partial_boldsymbolt partial_boldsymbolxrangle\n\nThe Weyl closure of a submodule S of D^r for rinmathbbN is defined to be the D-module Rcdot Scap D^r. This definition generalizes the definition of Tsai given in his PhD thesis which corresponds to the case m=0.\n\nAssuming that D^rS has finite holonomic rank and that generators gens of S are given as input of the function weyl_closure, it returns a Gröbner basis of a D-module S such that D^rS is holonomic and S subset Rcdot Scap D^r. It is not guaranteed that the algorithm returns the full weyl closure.","category":"section"},{"location":"OtherFunctionalities/#Example-2","page":"Other functionalities","title":"Example","text":"Let W_2 = mathbbQxylangle partial_t partial_xrangle be the second Weyl algebra and let f = frac1x^2 -y^3. The function f is annihilated by the operators partial_x  (x^2-y^3) and partial_y (x^2-y^3). But these two equations do not generate the full annihilator of f in W_2. A third equation can be found using the Weyl closure. \n\nFirst we load the package, define the algebra and the two obvious equations annihilating f.\n\njulia> using MultivariateCreativeTelescoping\n\njulia> A = OreAlg(order = \"grevlex x y > grevlex dx dy\",poldiffvars=([\"x\",\"y\"],[\"dx\",\"dy\"]))\nOre algebra\n\njulia> gens = [parse_OrePoly(\"dx*(x^2-y^3)\",A),parse_OrePoly(\"dy*(x^2-y^3)\",A)]\nVector of Ore polynomials \n\nThen we can compute its weyl closure\n\njulia> init = weyl_closure_init(A)\nWeylClosureInit\n\njulia> gb = weyl_closure(gens,A,init)\nVector of Ore polynomials \n\nAnd indeed we found a third equation.\n\njulia> prettyprint(f5(gens,A),A)\nvector of 2 OrePoly\n(1)dxy^3 + (-1)dxx^2\n(1)dyy^3 + (-1)dyx^2\n\njulia> prettyprint(gb,A)\nvector of 3 OrePoly\n(1)dyy^3 + (-1)dyx^2\n(3)dxy^2 + (2)dyx\n(3)dxx + (2)dyy + (1)\n\n<!– ","category":"section"},{"location":"OtherFunctionalities/#Integral-of-a-module","page":"Other functionalities","title":"Integral of a module","text":"Keeping the same notation as in the previous subsection, let S be a submodule of D^r and let M stackreldef= D^rS. The integral of the module M  is defined as \n\nint M = Mpartial M simeq D^r (S + sum_i=1^n partial_i D^r)\n\nThis package provides tools to compute in this quotient.  First a precomputation has to be done for which the user has to choose a value for the parameter sigma. The larger sigma is, the more relations between elements of  int M the algorithm will know. After this precomputation step is done, it is possible to try to find a smaller representative for an element of the quotient w.r.t. the order of A and to get every element up to a certain degree that can do not have smaller representatives (at least for the current sigma). \n\nIt is known that for sigma sufficiently large these functions returns respectively the smallest representative and all the irreducible monomials. The user is encouraged to experiment with this parameter.","category":"section"},{"location":"OtherFunctionalities/#Example-3","page":"Other functionalities","title":"Example","text":"In this example we take S equal to a holonomic ideal annihilating the rational function frac1x^3 + y^3 + z^3.\n\nFirst we load the package and define the algebra.\n\njulia> using MultivariateCreativeTelescoping\n\njulia> s = \"(x^3 + y^3 + z^3)\"\n\"(x^3 + y^3 + z^3)\"\n\njulia> A = OreAlg(order = \"grevlex x y z > grevlex dx dy dz\",poldiffvars=([\"x\",\"y\",\"z\"],[\"dx\",\"dy\",\"dz\"]))\nOre algebra\n\nThen we compute a Gröbner basis of S.\n\njulia> p = parse_OrePoly(s,A)\nOre polynomial\n\njulia> ann = [parse_OrePoly(\"dx*\"*s,A),parse_OrePoly(\"dy*\"*s,A),parse_OrePoly(\"dz*\"*s,A)]\nVector of Ore polynomials \n\njulia> init = weyl_closure_init(A)\nWeylClosureInit\n\njulia> gb = weyl_closure(ann,A,init)\nVector of Ore polynomials \n\nThen comes the precomputation step with sigma equals to 5\n\njulia> precomp = representative_in_integral_module_precomp(gb,5,A)\nRepInIntMod\n\nNow we can compute every monomials of degree less than 4 that do not have smaller representatives in the quotient (here sigma is large enough).\n\njulia> irr = irreducible_monomials(precomp,3,A)\nVector of Ore polynomials \n\njulia> prettyprint(irr,A)\nvector of 1 OrePoly\n(1)\n\nIndeed we can check that x^2 reduces to 0 but 1 doesn't. \n\njulia> red = representative_in_integral_module(precomp,parse_OrePoly(\"x^2\",A),A)\nOre polynomial\n\njulia> prettyprint(red,A)\n(0)\n\njulia> red2 = representative_in_integral_module(precomp,parse_OrePoly(\"1\",A),A)\nOre polynomial\n\njulia> prettyprint(red2,A)\n(1)\n\n–>","category":"section"},{"location":"OtherFunctionalities/#MultivariateCreativeTelescoping.f4","page":"Other functionalities","title":"MultivariateCreativeTelescoping.f4","text":"f4(gens :: Vector{OrePoly{T,M}}, A :: Alg)\n\nReturn a reduced Gröbner basis of the left ideal generated by gens for the monomial order defined in A.\n\n\n\n\n\n","category":"function"},{"location":"OtherFunctionalities/#MultivariateCreativeTelescoping.f5","page":"Other functionalities","title":"MultivariateCreativeTelescoping.f5","text":"f5(gens :: Vector{OrePoly{T,M}}, A :: Alg)\n\nReturn a reduced Gröbner basis of the left ideal generated by gens for the monomial order defined in A.\n\n\n\n\n\n","category":"function"},{"location":"OtherFunctionalities/#MultivariateCreativeTelescoping.weyl_closure_init","page":"Other functionalities","title":"MultivariateCreativeTelescoping.weyl_closure_init","text":"weyl_closure_init(A :: OreAlg)\n\nInitialisation function for weyl_closure\n\n\n\n\n\n","category":"function"},{"location":"OtherFunctionalities/#MultivariateCreativeTelescoping.weyl_closure","page":"Other functionalities","title":"MultivariateCreativeTelescoping.weyl_closure","text":"weyl_closure(gens::Vector{OrePoly{T,M}}, A :: OreAlg, init :: WeylClosureInit)\n\nReturn a Gröbner basis of a submodule of the Weyl closure of the module generated by gens.\n\n\n\n\n\n","category":"function"},{"location":"OtherFunctionalities/#MultivariateCreativeTelescoping.representative_in_integral_module_precomp","page":"Other functionalities","title":"MultivariateCreativeTelescoping.representative_in_integral_module_precomp","text":"representative_in_integral_module_precomp(gb :: Vector{OrePoly{T,M}},sigma :: Int ,A :: OreAlg) where {T,M}\n\nPrecomputation step for the representativeinintegralmodule and irreduciblemonomials functions. \n\n\n\n\n\n","category":"function"},{"location":"OtherFunctionalities/#MultivariateCreativeTelescoping.representative_in_integral_module","page":"Other functionalities","title":"MultivariateCreativeTelescoping.representative_in_integral_module","text":"representative_in_integral_module(precomp :: RepInIntMod,pol :: OrePoly, A :: OreAlg)\n\nCompute a smaller representative of the operator pol w.r.t. the order of A in the integral of the module defined by precomp \n\n\n\n\n\n","category":"function"},{"location":"OtherFunctionalities/#MultivariateCreativeTelescoping.irreducible_monomials","page":"Other functionalities","title":"MultivariateCreativeTelescoping.irreducible_monomials","text":"irreducible_monomials(precomp ::RepInIntMod, l :: Int, A :: OreAlg)\n\nReturns every monomial of degree up to l that do not have smaller representatives w.r.t the order of A  in the integral of the module defined in precomp. \n\nWarning: If the parameter sigma chosen for precomp is not large enough, this function may return some reducible monomials.\n\n\n\n\n\n","category":"function"},{"location":"Applications/","page":"-","title":"-","text":"This section describes concrete problems that have been solved using this package. ","category":"section"},{"location":"Applications/#Counting-k-regular-graphs","page":"-","title":"Counting k-regular graphs","text":"A graph is k regular if all its vertices have degree exactly k.  Let u(nk) be the number of k-regular graphs on n vertices.  We are interested in finding a recurrence relation on  u(nk) for fixed values of k.  Chyzak and Mishna were able to compute such a recurrence for k up to 7 [link]. The computation for k=7 took 24 weeks of CPU time.  With this package, we were able to obtain the same result in 7 minutes and to compute the recurrence for k=8. ","category":"section"},{"location":"Applications/#Example","page":"-","title":"Example","text":"Below is the script for k=6. It returns a linear differential equation annihilating the generating series  of the u(n6).  Excluding compilation time this computation takes approximately 3 seconds and returns an operator  of order 6 and degree 213.\n\nusing MultivariateCreativeTelescoping\nRpt = OreAlg(order = \"lex dt > grevlex p1 p2 p3 p4 p5 p6 > grevlex d1 d2 d3 d4 d5 d6\",\n                   ratdiffvars = ([\"t\"], [\"dt\"]),\n                   poldiffvars = ([\"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\"], [\"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\"])\n                  )\nGstring = \"[0+(1/6*t*p1^3-1/120*t*p1^5-t*p1+1/3*t*p3-1/5*t*p5-1/6*t*p1^2*p3+1/4*t*p1*p4-1/2*t*p1*p2+1/6*t*p2*p3+1/12*t*p1^3*p2-1/8*t*p1*p2^2+p1)*1+(-1/6*t*p3-1/12*t*p1^3+1/2*t*p1+1/4*t*p1*p2)*d1^2+(-t)*d2*d3+(1/2*t)*d1^2*d3+(-1/2*t*p1)*d2^2+(1/2*t)*d1*d2^2+(-1/6*t)*d1^3*d2+(t+1/2*t*p2-1/2*t*p1^2)*d1*d2+(1/120*t)*d1^5+(-1/6*t-1/12*t*p2+1/12*t*p1^2)*d1^3+(t-1/4*t*p4+1/8*t*p2^2+1/2*t*p2+1/24*t*p1^4-1/2*t*p1^2+1/3*t*p1*p3-1/4*t*p1^2*p2)*d1+(1/3*t*p3+1/6*t*p1^3-t*p1-1/2*t*p1*p2)*d2+(-t-1/2*t*p2+1/2*t*p1^2)*d3+(t*p1)*d4+(t)*d5+(-1/24*t*p1)*d1^4+(-t*p1)*d1*d3+(1/2*t*p1)*d1^2*d2+(-t)*d1*d4, 0+(-1/2*t*p2+1/4*t*p4-1/8*t*p2^2+1/2*t*p1^2-1/24*t*p1^4-1/3*t*p1*p3+1/4*t*p1^2*p2+p2-t)*1+(1/2*t+1/4*t*p2-1/4*t*p1^2)*d1^2+(-1/2*t)*d2^2+(-t*p1)*d1*d2+(1/6*t*p1)*d1^3+(1/3*t*p3+1/6*t*p1^3-t*p1-1/2*t*p1*p2)*d1+(-t-1/2*t*p2+1/2*t*p1^2)*d2+(t*p1)*d3+(t)*d4+(-1/24*t)*d1^4+(-t)*d1*d3+(1/2*t)*d1^2*d2, 0+(p3-1/6*t*p1^3+t*p1+1/2*t*p1*p2-1/3*t*p3)*1+(-1/2*t*p1)*d1^2+(-t)*d1*d2+(1/6*t)*d1^3+(-t-1/2*t*p2+1/2*t*p1^2)*d1+(t*p1)*d2+(t)*d3, 0+(p4-1/2*t*p1^2+t+1/2*t*p2)*1+(-1/2*t)*d1^2+(t*p1)*d1+(t)*d2, 0+(t)*d1+(-t*p1+p5)*1, 0+(p6-t)*1, 0+(1+1/3*p1*p3-1/18*p3^2+1/2*p2-1/4*p4+1/6*p6+1/8*p2^2-1/2*p1^2-1/8*p2*p4-1/5*p1*p5-1/720*p1^6+1/48*p1^4*p2-1/16*p1^2*p2^2-1/18*p1^3*p3+1/24*p1^4-1/4*p1^2*p2+1/48*p2^3+1/6*p1*p2*p3+1/8*p1^2*p4)*1+(-1)*d1*d5+(-1)*d2*d4+(1/2)*d1^2*d4+(-1/2)*d3^2+(1/6)*d2^3+(-1/720)*d1^6+(1/8*p4-1/2-1/16*p2^2-1/48*p1^4-1/6*p1*p3+1/8*p1^2*p2-1/4*p2+1/4*p1^2)*d1^2+(-p1)*d2*d3+(1/2*p1)*d1^2*d3+(1/2+1/4*p2-1/4*p1^2)*d2^2+(1/2*p1)*d1*d2^2+(-1/6*p1)*d1^3*d2+(1/2*p1*p2+p1-1/3*p3-1/6*p1^3)*d1*d2+(-1/6)*d1^3*d3+(1/120*p1)*d1^5+(1/18*p3+1/36*p1^3-1/12*p1*p2-1/6*p1)*d1^3+(1/5*p5+p1+1/2*p1*p2-1/4*p1*p4+1/120*p1^5-1/6*p2*p3+1/6*p1^2*p3+1/8*p1*p2^2-1/12*p1^3*p2-1/3*p3-1/6*p1^3)*d1+(-1/4*p4+1/2*p2+1+1/8*p2^2+1/24*p1^4+1/3*p1*p3-1/4*p1^2*p2-1/2*p1^2)*d2+(1/3*p3+1/6*p1^3-1/2*p1*p2-p1)*d3+(-1/2*p2+1/2*p1^2-1)*d4+(p1)*d5+(1)*d6+(-1/4)*d1^2*d2^2+(1/24)*d1^4*d2+(1)*d1*d2*d3+(1/48*p2-1/48*p1^2+1/24)*d1^4+(1/2*p2-1/2*p1^2+1)*d1*d3+(1)*dt+(-1/4*p2+1/4*p1^2-1/2)*d1^2*d2+(-p1)*d1*d4]\"\n\nG = parse_vector_OrePoly(Gstring, Rpt)\nB = f5(G, Rpt)\nres = MCT(one(Rpt), B, Rpt)","category":"section"},{"location":"MCT/#Multivariate-Creative-Telescoping","page":"Multivariate Creative Telescoping","title":"Multivariate Creative Telescoping","text":"Let us define the algebra \n\nD = mathbbQ(t)boldsymbolxlangle partial_t partial_boldsymbolxrangle\n\nwhere boldsymbolx = (x_1dotsx_n).\n\nLet I be a holonomic ideal of D and pin D.\n\nThe function MCT returns an operator Lin mathbbQ(t)langle partial_trangle such that Lpin I + sum_i=1^n partial_i D. In particular if I is the annihilator of a holonomic function f then L annihilates the integral \n\nint pf boldsymboldx\n\nprovided it has natural boundaries.\n\nThe signature of the function is the following.\n\nAssumption: \n\nspol corresponds to the operator p\ngb is a Gröbner basis of a holonomic subideal of I for the order defined in A\nA corresponds to the algebra D and its order eliminates dt\n\nIt is advised for efficiency to use an order of the form lex dt > grevlex [list of other polynomial variables].","category":"section"},{"location":"MCT/#Example","page":"Multivariate Creative Telescoping","title":"Example","text":"In this example we prove that the integral\n\nI(t) = int_gamma fracxx-tdx\n\nwhere gamma is a loop satisfies the differential equation tpartial_t -1 for any t inside that loop. This reflects the well-known fact I(t) = 2ipi t.\n\nFirst we load the package.\n\njulia> using MultivariateCreativeTelescoping\n\nWe define the algebra.\n\njulia> A = OreAlg(order = \"lex dt > grevlex x dx\",ratdiffvars=([\"t\"],[\"dt\"]),poldiffvars=([\"x\"],[\"dx\"]))\nOre algebra\n\nThen we compute an holonomic ideal included in the annihilator of 1(x-t). For more details see the Weyl closure subsection of the other functionalities section.\n\njulia> ann = [parse_OrePoly(\"dt*(x-t)\",A), parse_OrePoly(\"dx*(x-t)\",A)]\nVector of Ore polynomials\n\njulia> init = weyl_closure_init(A)\nWeylClosureInit\n\njulia> gb = weyl_closure(ann,A,init)\nVector of Ore polynomials \n\nWe can now apply the integration algorithm\n\njulia> LDE = MCT(parse_OrePoly(\"x\",A), gb, A)\nOre polynomial \n\njulia> prettyprint(LDE,A)\n(t)dt + (-1)","category":"section"},{"location":"MCT/#MultivariateCreativeTelescoping.MCT","page":"Multivariate Creative Telescoping","title":"MultivariateCreativeTelescoping.MCT","text":"MCT(spol :: OrePoly, gb :: Vector{OrePoly{T,M}}, A::OreAlg) where {T,M}\n\n\n\n\n\n","category":"function"},{"location":"QuickStart/#Quickstart","page":"Quick start","title":"Quickstart","text":"Let us demonstrate how this package works on a very simple example based on Cauchy's integral formula. We will check that the integral \n\nI(t) = int_gamma fracxx-tdx\n\nwhere gamma is a loop satisfies the differential equation tpartial_t -1 for any t inside that loop. This reflects the well-known fact I(t) = 2ipi t.\n\nWe load the package\n\njulia> using MultivariateCreativeTelescoping\n\nWe define the algebra \n\n mathbbQ(t)xlangle partial_t partial_xrangle\n\nwith the order lex dt > grevlex x dx. \n\njulia> A = OreAlg(order = \"lex dt > grevlex x dx\",ratdiffvars=([\"t\"],[\"dt\"]),poldiffvars=([\"x\"],[\"dx\"]))\nOre algebra\n\nWe remove the largest polynomial factor in the integrand (here x). This is done for efficiency reasons.  Then we define a set of differential equations satisfied by what remains, that is 1(x-t).  They must generate a D-finite ideal.\n\njulia> ann = [parse_OrePoly(\"dt*(x-t)\",A), parse_OrePoly(\"dx*(x-t)\",A)]\nVector of Ore polynomials\n\nThese equations do not necessarily define a holonomic ideal hence we have to take the Weyl closure. Note that the WeylClosure command returns only an holonomic approximation.\n\njulia> init = weyl_closure_init(A)\nWeylClosureInit\n\njulia> gb = weyl_closure(ann,A,init)\nVector of Ore polynomials \n\nWe can now apply the integration algorithm\n\njulia> LDE = MCT(parse_OrePoly(\"x\",A), gb, A)\nOre polynomial \n\njulia> prettyprint(LDE,A)\n(t)dt + (-1)","category":"section"},{"location":"#Introduction","page":"Package presentation","title":"Introduction","text":"MultivariateCreativeTelescoping is a package to compute linear differential equations satisfied by parametric integrals using a method called creative telescoping (see e.g. here for an introduction to creative telescoping). This package implements an algorithm recently presented at the JNCF conference [slides] and an article is being written.\n\nThis algorithm is dedicated to integrals with natural boundaries of the form \n\n    I(t) = int f(t boldsymbolx) d boldsymbolx\n\nwhere boldsymbolx=(x_1dotsx_n) and f is a D-finite/holonomic function that satisfies PDEs with coefficients in mathbbQ(tboldsymbolx).","category":"section"},{"location":"#Installation","page":"Package presentation","title":"Installation","text":"Open Julia in a terminal and execute the following line to install the package.\n\n] add MultivariateCreativeTelescoping\n\nThen you should be able to load the package in Julia's REPL with the command\n\nusing MultivariateCreativeTelescoping","category":"section"}]
}
